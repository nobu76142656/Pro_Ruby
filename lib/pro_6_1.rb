#
# 正規表現を理解する
#

# 正規表現とは、パターンを指定して、
# 文字列を効率良く検索、置き換えするためのミニ言語。

text = <<TEXT
I love Ruby.
Python is a great language.
Java and JavaScript are different.
TEXT

p text.scan(/[A-Z][A-Za-z]+/)



#
# 手と目で覚える正規表現 その1
# https://qiita.com/jnchito/items/893c887fbf19e17d3ff9
#

# \d は1個の半角数字(0,1,2,3,4,5,6,7,8,9)

text = <<TEXT
電話：042-743-3345
電話：03-1234-5678
電話：090-1234-5678
電話：0795-12-3456
電話：04992-1-2345
TEXT
p text.scan(/\d\d\d-\d\d\d-\d\d\d\d/)

# {n,m} は「直前の文字が n 個以上、m 個以下」

p text.scan(/\d{2,5}-\d{1,4}-\d{4,4}/)


# カッコのに対応する


# 「AまたはBのいずれか1文字」表す場合は [AB] 。
# [ ]の中の文字数に制限はありません。
# [ABC] と書けば、「AまたはBまたはCのいずれか1文字」の意味
# ハイフンまたはカッコ（開き）と、ハイフンまたはカッコ（閉じ）は
# それぞれ、[-(]、[-)] と表現します。

text =<<TEXT
電話：03(1234)5678
電話：090-1234-5678
電話：0795(12)3456
電話：04992-1-2345
TEXT

p text.scan(/\d{2,5}[-(]\d{1,4}[-)]\d{4}/)


# -(ハイフン)に注意


# [a-zA-Z0-9] であれば「aまたはbまたは・・・z、AまたはBまたは・・・Z、

# 0または1または・・・9」の意味になります。
# （端的に言うと、これは「半角英数字1文字」の意味です）

# ただし、[-az] や [az-] のように、ハイフンが [ ] の最初、# または最後に置かれ
# ると「ハイフン1文字」の意味に変わります。

# なので [-az] や [az-] は「aまたはzまたはハイフンのいずれか1文字」
# の意味になります。


# 正規表現を使ってそこそこの精度で文字列を抽出し、残りはプログラムで処理。


#【まとめ】
# \d は「半角数字1文字」を表す
# {n,m} は「直前の文字が n 文字以上、m 文字以下」であることを表す
# {n} は「直前の文字がちょうど n 文字」であることを表す
# [AB] は「AまたはBが1文字」であることを表す
# [a-z] と [-az] ではハイフンの意味が異なる
# 正規表現の正確さと複雑さはトレードオフになることが多い



#
# 手と目で覚える正規表現 その2
# https://qiita.com/jnchito/items/64c3fdc53766ac6f2008
#

text =<<TEXT
クープバゲットのパンは美味しかった。
今日はクープ バゲットさんに行きました。
クープ　バゲットのパンは最高。
ジャムおじさんのパン、ジャムが入ってた。
また行きたいです。クープ・バゲット。
クープ・バケットのパン、売り切れだった（><）
TEXT


# [ 　・] は半角スペース、全角スペース、中黒
p text.scan(/クープ[ 　・]バゲット/)


# バゲットとバケットの両方にマッチ
p text.scan(/クープ[ 　・]バ[ゲケ]ット/)


# ここまでで空白がアクパターンはマッチしているが、一行目の空白があかないパターン
# はマッチしていない。
# ? というメタ文字をつかう。「～が1文字、またはなし」

p text.scan(/クープ[ 　・]?バ[ゲケ]ット/)


# [ 　・]は、. という「任意の1文字」を表すメタ文字で変えられる。
p text.scan(/クープ.?バ[ゲケ]ット/)
p text.split(/\n/).grep(/クープ.?バ[ゲケ]ット/)



#
# 置き換え
#

# CSV形式に置き換える
# CSV形式：文字列と,(カンマ)で区切られた形式

text = <<TEXT
<select name="game_console">
<option value="wii_u">Wii U</option>
<option value="ps4">プレステ4</option>
<option value="gb">ゲームボーイ</option>
</select>
TEXT

# valueの部分
# 「value=、ダブルクオート、英数字またはアンダースコアが1文字以上、ダブルクオート」

# 直前の文字が1文字以上：＋メタタグ
# 英数字またはアンダースコアは[a-z0-9_]

p text.scan(/value="[a-z0-9_]+"/)


# >で始まり<で終わる箇所の正規表現 >.+<
p text.scan(/value="[a-z0-9_]+"/)



# １、行全体にマッチする正規表現。
# スラッシュをエスケープするためのバックスラッシュ\が入っている。
p text.scan(/<option value="[a-z0-9_]+">.+<\/option>/)


# ２、valueと表示テキストを()で囲むとキャプチャできる。
# Rubyの場合は多次元配列にはいる。

p text.scan(/<option value="([a-z0-9_]+)">(.+)<\/option>/)
#=> [["wii_u", "Wii U"], ["ps4", "プレステ4"], ["gb", "ゲーム ボーイ"]]


# ３、ここからはATOMを使う。デスクトップ re.rb

# 置き換えで$1,$2を指定。$1,$2(Rubyでは\1,\2)はそれぞれキャプチャされた1番目の文字列
# と、2番目の文字列を表している。キャプチャは()で行われている。


# 1番目に()で囲われた場所が$1として間に,を入れて2番目に()で囲われた場所に
# 置き換わっている。それ以外の文字列は消える。



# 現状、optionがマッチしていない。
# マッチさせるために直前の文字が0文字以上を表す場合は* を使う。 .+を.*に変える。

text = <<TEXT
<select name="game_console">
<option value="none"></option>
<option value="wii_u">Wii U</option>
<option value="ps4">プレステ4</option>
<option value="gb">ゲームボーイ</option>
</select>
TEXT
# Rubyではmatch groupが表示される。
p text.scan(/<option value="([a-z0-9_]+)">(.*)<\/option>/)


# 現状selectがマッチされていない。( select)?でselectがあるかないか？で
# マッチさせられる。

# このままだとここの()もキャプチャとして計算されてしまうので、(?: )とすれば
# キャプチャされない。


# 0-9は\dと同じなので置き換えられる。
# [a-z\d_]+ は \w+ と書き換えてもほぼ同じ意味。\wは英単語を構成する文字の意。



# Rubyでの置き換え
html = <<-HTML
<select name="game_console">
<option value="none"></option>
<option value="wii_u" selected>Wii U</option>
<option value="ps4">プレステ4</option>
<option value="gb">ゲームボーイ</option>
</select>
HTML

replaced = html.gsub(/<option value="(\w+)"(?: selected)?>(.*)<\/option>/, '\1,\2')

puts replaced

# 【まとめ】
# ? は「直前の文字が1個、または無し」を表す
# . は「任意の1文字」を表す
# + は「直前の文字が1個以上」を表す
# * は「直前の文字が0個以上」を表す
# ( ) はマッチする部分をキャプチャ（捕捉）する
# キャプチャした部分は置換するときに $1 や \1 で参照できる
# \w は「英単語を構成する文字（半角英数字とアンダースコア）」を表す
# [^AB] は「AでもなくBでもない任意の1文字」を表す
# 正規表現中の特別な文字は \ でエスケープする
# ( ) はキャプチャだけでなく、グループ化にも使われる
# (ABC)? は「文字列 ABC があり、または無し」を表す
# (?: ) はキャプチャ無しでグループ化する場合に使う
# * と + は「貪欲」で最長マッチを返すため、使い方を誤ると思いがけない結果が返る
# *? や +? にすると、最短マッチを返す
# テキストエディタで重要なテキストを置換する際は、ひとつずつ確認しながら置換する



#
# 手と目で覚える正規表現 その3
# https://qiita.com/jnchito/items/6f0c885c1c4929092578
#

# 空行にあるスペースやタブを見つける。


# スペース+ でスペースが1文字以上続く正規表現。
# ^ + ^は行頭を表す正規表現。

# 文字そのものではなく、マッチした位置を示すメタ文字をアンカーと呼ぶ。


# ^ +$ $は行末を意味するアンカー。「行頭から行末までスペースが1文字以上続く」


#  ^[ \t]+$ これでスペースとタブ文字を選択できる。\t タブ文字


text = <<-TEXT
def hello(name)
  puts "Hello, \#{name}!"
end

hello('Alice')
     
hello('Bob')
	
hello('Carol')
TEXT

# ★無駄なスーペースやタブを削除。
puts text.gsub(/^[ \t]+$/, '')

# [ \t]+$ 行末の無駄なスペースを選択

# ^[ \t]+ 行頭からスペースやタブ文字が1文字以上続く

# :[ \t]* コロンの後ろにスペースまたはタブ文字が0文字以上

# \s 半角スペースやタブ文字、改行文字など、目に見えない「空白文字全般」を表す。

# :[ \t]* を :\s* とできる。

# Rubyの場合 \s = \t \r \n \f   改行文字も含まれるので注意。

# ,を\t に置き換えるなどに使う。

# ^.+heroku\/api.+$ 「行頭から何らかの文字が1文字以上続き、heroku/apiが現れ
# その後行末まで何らかの文字が1文字以上続く。

# | (パイプライン)メタ文字 「または」
# ^.+heroku\/(api|scheduler).+$

# 削除したあと空白が残ってしまう場合は正規表現の一番最後に \n を入れる。

# 行頭文字の ^ は[^AB]と使うと、AでもなくBでもない文字1文字となる。否定条件。
# [AB^] はAまたはBまたは、^ のいずれかの文字となる。



# 【まとめ】
# ^ は行頭を表す
# $ は行末を表す
# \t はタブ文字を表す
# \n は改行文字を表す
# \s は空白文字（スペース、タブ文字、改行文字等）を表す
# ABC|DEF は「文字列ABCまたは文字列DEF」のOR条件を表す
# 改行コードは環境によって異なる場合がある


#
# Rubyにおける正規表現オブジェクト
#

# Rubyでは正規表現は/正規表現/と、/で囲む。


regex = /\d{3}-\d{4}/

# =~ を使うと正規表現と【文字列】がマッチすれば真(正確にはマッチした位置)、
# しなければ偽(nil)が返る。

p 7 =~ /\d/    #=> nil
p '7' =~ /\d/  #=> 0

p regex =~ '123-3234'   #=> 0


# !~ はマッチした時falseを、マッチしなかった時true
p regex !~ '3432-8888' #=> false



#
# キャプチャ機能
#


# Rubularでのやりかた。
# 私の誕生日は1977年7月17日です。

# \d+年\d+月\d+日で1977年7月17日がマッチする。

# 数字の部分だけキャプチャする。
# (\d+)年(\d+)月(\d+)日

# 1.	1977
# 2.	7
# 3.	17


# Rubyでのやりかた

text = '私の誕生日は1977年7月17日です。'


# キャプチャを活用する一つの方法は、matchメソッドを使うこと。# 文字列が正規表現
# にマッチすると、MatchDataオブジェクトが返る。マッチしない場合nil。が返る。

p m = /(\d+)年(\d+)月(\d+)日/.match(text)
#=> <MatchData "1977年7月17日" 1:"1977" 2:"7" 3:"17">

p m[1]
p m[2]
p m[3]
p m[2,3]
p m[1..3]

# この性質を使って、条件分岐の中で真偽値の判定とローカル変数への代入を同時に
# やるコードがよく使われる。

text = '私の誕生日は1977年7月17日です。'
if m = /(\d+)年(\d+)月(\d+)日/.match(text)
  # マッチした場合の処理
else
  # マッチしなかった場合の処理
end

# matchメソッドはStirngクラスとRegexpクラスの両方に定義されているため、
# 文字列と正規表現オブジェクトを入れ替えても同じように動作する。


# キャプチャの結果に名前を付ける。# 何番目が何の文字化をプログラマが意識しない
# といけない。そこでキャプチャには(?<name>)というメタ文字で名前を付けれる。

text = '私の誕生日は1977年7月17日です。'
m = /(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/.match(text)
p m

p m['year']
p m[1]


# 名前付きキャプチャのもう1つの機能として、左辺に正規表現リテラルを、
# 右辺に文字列を置いて =~ キャプチャの名前がそのままローカル変数に割り当てられる。
# 左右逆でも使えない。正規表現オブジェクトをいったん変数に入れてしまっても使えない。

text = '私の誕生日は1977年7月17日です。'

if /(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/ =~ text
  puts "#{year}/#{month}/#{day}"
end




#
# ★正規表現と組み合わせると便利なStringクラスのメソッド p188
#


# scan
# 引数で渡した正規表現にマッチする部分を配列に入れて返す。非破壊。

'123 456 789'.scan(/\d+/) #=> ["123","456","789"]

# 研究
text = "expires 有効期限\n, authenticated 認証\n"
p text.scan(/\w+/)


# [],slice,slice!
# []に正規表現を渡すと、正規表現にマッチした部分を抜き出す。
text = '郵便番号は123-456です'
p text[/\d{3}-\d{4}/]
p text.slice(/\d{3}-\d{4}/)


# split
# マッチした文字列を区切り文字にして文字列を分解して配列として返す。
text = '123,123-456'
p text.split(',')

p text.split(/,|-/)



# gsub,gsub!
# 第1引数の正規表現にマッチした文字列を第2引数の文字列で置き換える。
# \nがどうしても正規表現でマッチしない。Macでやるしかないか。

# ★Rubyの場合、一重引用符の中では、（\\と\'を除いて）
# ★エスケープシーケンスは無効となります。
# ★二重引用符か正規表現リテラルで書いてください。" "を使っていた。のが原因。

text = '\n'
p text.gsub('\n', ':')


# 第2引数にハッシュを渡して変換のルールを指定することができる。
text = '123,123-456'
hash = { ','=>':', '-'=>'/' }
p text.gsub(/,|-/, hash)



#
# 例題：Rubyのハッシュ記法を変換する
#

convert_hash_syntax.rb
convert_hash_syntax_test.rb


#
# 正規表現についてもっと詳しく
#





